#!/usr/bin/python
# NumaConnect checker r1

import os, time, optparse
from nclib import Platform, Numachip, Northbridge

class Node:
	def write(self, bus, dev, fun, reg, val):
		numachip.mmcfg_raw_write(self.sci, bus, dev, fun, reg, val)

	def read(self, bus, dev, fun, reg):
		return numachip.mmcfg_raw_read(self.sci, bus, dev, fun, reg)

	def __init__(self, sci):
		self.sci = sci
		# count northbridges
		self.nbs = (numachip.mmcfg_raw_read(sci, 0, 0x18, 0, 0x60) >> 4) & 7

	def ncensure(self, reg, expect):
		val = numachip.csr_raw_read(self.sci, numachip.regs[reg])
		if val != expect:
			if self.errors == 0: # print newline for first error
				print '\n %03x' % self.sci,

			print '%s:%08x' % (reg, val),
			self.errors += 1

	def nbensure(self, reg, expect):
		val = numachip.csr_raw_read(self.sci, numachip.regs[reg])
		if val != expect:
			if self.errors == 0: # print newline for first error
				print '\n %03x' % self.sci,

			print '%s:%08x' % (reg, val),
			self.errors += 1

	def mces(self):
		for nb in range(self.nbs):
			statreg = Northbridge.regs['MC STATUS']
			status = numachip.mmcfg_raw_read(self.sci, 0, 0x18 + nb, statreg >> 12, statreg & 0xfff)
			status |= numachip.mmcfg_raw_read(self.sci, 0, 0x18 + nb, statreg >> 12, (statreg & 0xfff) + 4) << 32
			if not status:
				return

			addrreg = Northbridge.regs['MC ADDR']
			addr = numachip.mmcfg_raw_read(self.sci, 0, 0x18 + nb, addrreg >> 12, addrreg & 0xfff)
			addr |= numachip.mmcfg_raw_read(self.sci , 0, 0x18 + nb, addrreg >> 12, (addrreg & 0xfff) + 4) << 32

			if self.errors == 0: # print newline for first error
				print '\n %03x' % self.sci,

			print 'NB%uMCE:%016x,%016x' % (nb, status, addr),
			self.errors += 1

	def check(self):
		self.errors = 0

		try:
			self.ncensure('CDATA_ERROR_STATR', 0x00000000)
			self.ncensure('MCTAG_ERROR_STATR', 0x00000000)
			self.ncensure('ERROR_STATUS', 0x00000000)
			self.ncensure('ERROR_NFSTAT', 0x01000100)
			self.ncensure('ERROR_FSTAT', 0x00000000)

			if platform.oemn.size_x:
				self.ncensure('HSSXA_STAT_1', 0x00000100)
				self.ncensure('HSSXB_STAT_1', 0x00000100)
				self.ncensure('PHYXA_ELOG', 0x00000000)
				self.ncensure('PHYXB_ELOG', 0x00000000)
				self.ncensure('PHYXA_LINK_STAT', 0x00001fff)
				self.ncensure('PHYXB_LINK_STAT', 0x00001fff)

			if platform.oemn.size_y:
				self.ncensure('HSSYA_STAT_1', 0x00000100)
				self.ncensure('HSSYB_STAT_1', 0x00000100)
				self.ncensure('PHYYA_ELOG', 0x00000000)
				self.ncensure('PHYZB_ELOG', 0x00000000)
				self.ncensure('PHYYA_LINK_STAT', 0x00001fff)
				self.ncensure('PHYYB_LINK_STAT', 0x00001fff)

			if platform.oemn.size_z:
				self.ncensure('HSSZA_STAT_1', 0x00000100)
				self.ncensure('HSSZB_STAT_1', 0x00000100)
				self.ncensure('PHYZA_ELOG', 0x00000000)
				self.ncensure('PHYZB_ELOG', 0x00000000)
				self.ncensure('PHYZA_LINK_STAT', 0x00001fff)
				self.ncensure('PHYZB_LINK_STAT', 0x00001fff)

			if options.lean:
				return self.errors

			self.mces()
		except Numachip.TimeoutException:
			if self.errors == 0: # print newline for first error
				print '\n %03x' % self.sci,
			print 'timeout',
		except Numachip.HTErrorException:
			if self.errors == 0: # print newline for first error
				print '\n %03x' % self.sci,
			print 'HT error',
		except Numachip.BlockedException:
			if self.errors == 0: # print newline for first error
				print '\n %03x' % self.sci,
			print 'blocked',

		return self.errors

### start

if os.getuid():
	raise SystemExit('error: please run as root')

parser = optparse.OptionParser()
parser.add_option('--verbose', dest='verbose', default=0, action='count', help='increase verbosity')
parser.add_option('--once', dest='once', action='store_true', default=False, help='check once rather than periodically')
parser.add_option('--lean', dest='lean', action='store_true', default=False, help='check numachip registers only')
parser.add_option('--local', dest='local', action='store_true', default=False, help='check local registers only')

options, args = parser.parse_args()
verbose = options.verbose

platform = Platform()
numachip = Numachip(platform)

colours = {
	'default':  '\033[0m',
	'warning':  '\033[33m', # yellow
	'error':    '\033[31m', # red
	'good':     '\033[32m', # green
}

nodes = []

for z in range(max(platform.oemn.size_z, 1)):
	for y in range(max(platform.oemn.size_y, 1)):
		for x in range(max(platform.oemn.size_x, 1)):
			nodes.append(Node(x | y << 4 | z << 8))

try:
	while True:
	#	print '\033\143'
		print time.strftime('%Y-%m-%d %H:%M:%S', time.localtime()),

		errors = 0
		for node in nodes:
			errors += node.check()

		if errors == 0:
			print 'no errors',
		print

		if options.once:
			break

		time.sleep(3)
except KeyboardInterrupt:
	pass
